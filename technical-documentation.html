<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DueDock Technical Documentation</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            color: #1a73e8;
            border-bottom: 2px solid #1a73e8;
            padding-bottom: 10px;
        }
        h2 {
            color: #5f6368;
            margin-top: 30px;
        }
        h3 {
            color: #80868b;
            margin-top: 25px;
        }
        h4 {
            color: #9aa0a6;
            margin-top: 20px;
        }
        .code-block {
            background-color: #f8f9fa;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #4285f4;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
            overflow-x: auto;
        }
        .swift-code {
            background-color: #282c34;
            color: #abb2bf;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            font-family: 'SF Mono', Monaco, monospace;
            overflow-x: auto;
        }
        .string { color: #98c379; }
        .keyword { color: #c678dd; }
        .type { color: #e5c07b; }
        .comment { color: #5c6370; font-style: italic; }
        .function { color: #61afef; }
        .number { color: #d19a66; }
        
        .api-section {
            background-color: #e8f0fe;
            padding: 15px;
            border-left: 4px solid #1a73e8;
            margin: 20px 0;
        }
        .model-diagram {
            background-color: #fef7e0;
            padding: 15px;
            margin: 15px 0;
            border-left: 4px solid #fbbc04;
            border-radius: 4px;
        }
        .performance-note {
            background-color: #e6f4ea;
            padding: 15px;
            border-left: 4px solid #34a853;
            margin: 20px 0;
        }
        .warning {
            background-color: #fce8e6;
            padding: 15px;
            border-left: 4px solid #ea4335;
            margin: 20px 0;
        }
        .tip {
            background-color: #f3f8ff;
            padding: 15px;
            border-left: 4px solid #1a73e8;
            margin: 20px 0;
        }
        code {
            background-color: #f1f3f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
        }
        .highlight {
            font-weight: bold;
            color: #1a73e8;
        }
        .endpoint {
            font-family: 'SF Mono', Monaco, monospace;
            background-color: #f8f9fa;
            padding: 8px 12px;
            border-radius: 4px;
            margin: 5px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>DueDock Technical Documentation</h1>
    
    <div class="api-section">
        <strong>Complete technical reference for developers.</strong> This documentation covers DueDock's architecture, data models, APIs, and implementation details.
    </div>

    <h2>Architecture Overview</h2>

    <h3>Technology Stack</h3>
    <div class="code-block">
        <strong>Platform:</strong> iOS 17.0+<br>
        <strong>Language:</strong> Swift 5.9<br>
        <strong>UI Framework:</strong> SwiftUI<br>
        <strong>Data Persistence:</strong> SwiftData + Core Data<br>
        <strong>Architecture:</strong> MVVM (Model-View-ViewModel)
    </div>

    <h3>Project Structure</h3>
    <pre>
DueDock/
├── DueDock/
│   ├── Models/           # SwiftData models
│   ├── Views/            # SwiftUI views
│   ├── ViewModels/       # Business logic
│   ├── Services/         # Data services
│   ├── Utilities/        # Helper functions
│   └── Resources/        # Assets, Localizable strings
├── DueDockTests/         # Unit tests
├── DueDockUITests/       # UI tests
└── DueDock.xcodeproj     # Project configuration
    </pre>

    <h2>Data Models</h2>

    <h3>Core Models</h3>
    
    <div class="model-diagram">
        <strong>Primary Data Models:</strong>
    </div>

    <div class="swift-code">
<span class="comment">// Core Bill Model</span>
<span class="keyword">@Model</span>
<span class="keyword">final class</span> <span class="type">Bill</span> {
    <span class="keyword">var</span> id: <span class="type">UUID</span>
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> amount: <span class="type">Double</span>
    <span class="keyword">var</span> actualAmount: <span class="type">Double</span>?
    <span class="keyword">var</span> dueDate: <span class="type">Date</span>
    <span class="keyword">var</span> frequency: <span class="type">BillFrequency</span>
    <span class="keyword">var</span> isPaid: <span class="type">Bool</span>
    <span class="keyword">var</span> account: <span class="type">Account</span>?
    <span class="keyword">var</span> tags: <span class="type">Set</span>&lt;<span class="type">Tag</span>&gt;
    <span class="keyword">var</span> createdAt: <span class="type">Date</span>
    <span class="keyword">var</span> updatedAt: <span class="type">Date</span>
}

<span class="comment">// Account Model</span>
<span class="keyword">@Model</span>
<span class="keyword">final class</span> <span class="type">Account</span> {
    <span class="keyword">var</span> id: <span class="type">UUID</span>
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> balance: <span class="type">Double</span>
    <span class="keyword">var</span> type: <span class="type">AccountType</span>
    <span class="keyword">var</span> bills: <span class="type">Set</span>&lt;<span class="type">Bill</span>&gt;
    <span class="keyword">var</span> isActive: <span class="type">Bool</span>
}
    </div>

    <h3>Supporting Models</h3>

    <div class="swift-code">
<span class="comment">// Income Model</span>
<span class="keyword">@Model</span>
<span class="keyword">final class</span> <span class="type">Income</span> {
    <span class="keyword">var</span> id: <span class="type">UUID</span>
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> amount: <span class="type">Double</span>
    <span class="keyword">var</span> date: <span class="type">Date</span>
    <span class="keyword">var</span> frequency: <span class="type">IncomeFrequency</span>
    <span class="keyword">var</span> isRecurring: <span class="type">Bool</span>
}

<span class="comment">// Payment Record Model</span>
<span class="keyword">@Model</span>
<span class="keyword">final class</span> <span class="type">PaymentRecord</span> {
    <span class="keyword">var</span> id: <span class="type">UUID</span>
    <span class="keyword">var</span> bill: <span class="type">Bill</span>
    <span class="keyword">var</span> amount: <span class="type">Double</span>
    <span class="keyword">var</span> paymentDate: <span class="type">Date</span>
    <span class="keyword">var</span> paymentType: <span class="type">PaymentType</span>
}
    </div>

    <h2>Core Services</h2>

    <h3>Bill Calculation Service</h3>

    <div class="swift-code">
<span class="keyword">class</span> <span class="type">BillCalculationService</span> {
    
    <span class="keyword">func</span> <span class="function">calculateCoverage</span>(bills: [<span class="type">Bill</span>], 
                             balance: <span class="type">Double</span>, 
                             endDate: <span class="type">Date</span>) -> <span class="type">CoverageResult</span> {
        
        <span class="keyword">let</span> dueBills = bills.<span class="function">filter</span> { bill <span class="keyword">in</span>
            !bill.isPaid && bill.dueDate <= endDate
        }
        
        <span class="keyword">let</span> totalDue = dueBills.<span class="function">reduce</span>(<span class="number">0</span>) { $0 + $1.actualAmount ?? $1.amount }
        <span class="keyword">let</span> available = balance - totalDue
        
        <span class="keyword">return</span> <span class="type">CoverageResult</span>(
            totalDue: totalDue,
            availableBalance: available,
            coverageStatus: available >= <span class="number">0</span> ? .healthy : .insufficient,
            conflictingBills: <span class="function">findConflicts</span>(bills: dueBills)
        )
    }
    
    <span class="keyword">private func</span> <span class="function">findConflicts</span>(bills: [<span class="type">Bill</span>]) -> [<span class="type">Date</span>: [<span class="type">Bill</span>]] {
        <span class="keyword">let</span> grouped = <span class="type">Dictionary</span>(grouping: bills) { $0.dueDate }
        <span class="keyword">return</span> grouped.<span class="function">filter</span> { $0.value.count > <span class="number">1</span> }
    }
}
    </div>

    <h3>Data Persistence Service</h3>

    <div class="swift-code">
<span class="keyword">class</span> <span class="type">DataPersistenceService</span> {
    
    <span class="keyword">@Environment</span>(\.modelContext) <span class="keyword">private var</span> modelContext
    
    <span class="keyword">func</span> <span class="function">saveBill</span>(_ bill: <span class="type">Bill</span>) <span class="keyword">throws</span> {
        bill.updatedAt = <span class="type">Date</span>()
        <span class="keyword">try</span> modelContext.<span class="function">save</span>()
    }
    
    <span class="keyword">func</span> <span class="function">deleteBill</span>(_ bill: <span class="type">Bill</span>) <span class="keyword">throws</span> {
        modelContext.<span class="function">delete</span>(bill)
        <span class="keyword">try</span> modelContext.<span class="function">save</span>()
    }
    
    <span class="keyword">func</span> <span class="function">exportData</span>() <span class="keyword">throws</span> -> <span class="type">Data</span> {
        <span class="keyword">let</span> encoder = <span class="type">JSONEncoder</span>()
        encoder.dateEncodingStrategy = .iso8601
        <span class="keyword">return</span> <span class="keyword">try</span> encoder.<span class="function">encode</span>(<span class="function">getAllBills</span>())
    }
}
    </div>

    <h2>SwiftUI Views Architecture</h2>

    <h3>Main Views</h3>

    <div class="swift-code">
<span class="keyword">struct</span> <span class="type">ContentView</span>: <span class="type">View</span> {
    <span class="keyword">@Environment</span>(\.modelContext) <span class="keyword">private var</span> modelContext
    <span class="keyword">@Query</span> <span class="keyword">private var</span> bills: [<span class="type">Bill</span>]
    
    <span class="keyword">@StateObject</span> <span class="keyword">private var</span> calculationService = <span class="type">BillCalculationService</span>()
    
    <span class="keyword">var body</span>: <span class="type">some View</span> {
        <span class="type">TabView</span> {
            <span class="type">DashboardView</span>(bills: bills)
                .<span class="function">tabItem</span> { <span class="type">Label</span>(<span class="string">"Dashboard"</span>, systemImage: <span class="string">"house.fill"</span>) }
            
            <span class="type">BillsListView</span>(bills: bills)
                .<span class="function">tabItem</span> { <span class="type">Label</span>(<span class="string">"Bills"</span>, systemImage: <span class="string">"list.bullet"</span>) }
            
            <span class="type">CalendarView</span>(bills: bills)
                .<span class="function">tabItem</span> { <span class="type">Label</span>(<span class="string">"Calendar"</span>, systemImage: <span class="string">"calendar"</span>) }
        }
    }
}
    </div>

    <h3>Dashboard Implementation</h3>

    <div class="swift-code">
<span class="keyword">struct</span> <span class="type">DashboardView</span>: <span class="type">View</span> {
    <span class="keyword">@Query</span> <span class="keyword">private var</span> accounts: [<span class="type">Account</span>]
    <span class="keyword">@State</span> <span class="keyword">private var</span> selectedPeriod: <span class="type">PlanningPeriod</span> = .coverageCheck
    
    <span class="keyword">var body</span>: <span class="type">some View</span> {
        <span class="type">NavigationView</span> {
            <span class="type">ScrollView</span> {
                <span class="type">VStack</span>(spacing: <span class="number">16</span>) {
                    <span class="type">OverviewCard</span>(accounts: accounts)
                    <span class="type">PlanningPeriodSelector</span>(selection: $selectedPeriod)
                    <span class="type">BillsSummaryView</span>(period: selectedPeriod)
                    <span class="type">QuickActionsView</span>()
                }
                .padding()
            }
            .navigationTitle(<span class="string">"DueDock"</span>)
        }
    }
}
    </div>

    <h2>API Reference</h2>

    <h3>Calculation APIs</h3>

    <div class="api-section">
        <strong>Core Calculation Functions</strong>
    </div>

    <div class="swift-code">
<span class="comment">// Coverage Check API</span>
<span class="keyword">func</span> <span class="function">calculateCoverageCheck</span>(
    bills: [<span class="type">Bill</span>],
    balance: <span class="type">Double</span>,
    nextIncomeDate: <span class="type">Date</span>
) -> <span class="type">CoverageCheckResult</span>

<span class="comment">// Planning Period API</span>
<span class="keyword">func</span> <span class="function">calculatePlanningPeriod</span>(
    bills: [<span class="type">Bill</span>],
    income: [<span class="type">Income</span>],
    startDate: <span class="type">Date</span>,
    endDate: <span class="type">Date</span>
) -> <span class="type">PlanningPeriodResult</span>

<span class="comment">// Variable Bill API</span>
<span class="keyword">func</span> <span class="function">updateVariableBill</span>(
    bill: <span class="type">Bill</span>,
    actualAmount: <span class="type">Double</span>
) <span class="keyword">throws</span>
    </div>

    <h3>Data Management APIs</h3>

    <table>
        <tr>
            <th>Function</th>
            <th>Parameters</th>
            <th>Return</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><code>createBill</code></td>
            <td>name, amount, dueDate, frequency</td>
            <td>Bill</td>
            <td>Creates new bill</td>
        </tr>
        <tr>
            <td><code>updateBill</code></td>
            <td>bill, updates</td>
            <td>Void</td>
            <td>Updates existing bill</td>
        </tr>
        <tr>
            <td><code>deleteBill</code></td>
            <td>bill</td>
            <td>Void</td>
            <td>Deletes bill with undo</td>
        </tr>
        <tr>
            <td><code>dockBill</code></td>
            <td>bill, paymentType</td>
            <td>PaymentRecord</td>
            <td>Marks bill as paid</td>
        </tr>
    </table>

    <h2>Performance Optimization</h2>

    <h3>SwiftData Query Optimization</h3>

    <div class="performance-note">
        <strong>Query Performance Tips:</strong>
    </div>

    <div class="swift-code">
<span class="comment">// Efficient filtering with predicates</span>
<span class="keyword">@Query</span>(
    filter: <span class="type">#Predicate</span>&lt;<span class="type">Bill</span>&gt; { bill <span class="keyword">in</span>
        !bill.isPaid && bill.dueDate >= <span class="type">Date</span>()
    },
    sort: [<span class="type">SortDescriptor</span>(\<.<span class="type">Bill</span>.dueDate)]
)
<span class="keyword">private var</span> upcomingBills: [<span class="type">Bill</span>]

<span class="comment">// Batch operations for performance</span>
<span class="keyword">func</span> <span class="function">batchUpdateBills</span>(_ bills: [<span class="type">Bill</span>], updates: <span class="type">BillUpdates</span>) {
    <span class="keyword">for</span> bill <span class="keyword">in</span> bills {
        <span class="function">applyUpdates</span>(updates, to: bill)
    }
    <span class="keyword">try</span>? modelContext.<span class="function">save</span>()
}
    </div>

    <h3>Memory Management</h3>

    <div class="swift-code">
<span class="keyword">class</span> <span class="type">BillCalculationService</span>: <span class="type">ObservableObject</span> {
    <span class="keyword">private var</span> cancellables = <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt;()
    
    <span class="keyword">init</span>() {
        <span class="function">setupMemoryOptimizations</span>()
    }
    
    <span class="keyword">private func</span> <span class="function">setupMemoryOptimizations</span>() {
        <span class="comment">// Debounce rapid calculations</span>
        $calculationTrigger
            .<span class="function">debounce</span>(for: .<span class="function">milliseconds</span>(<span class="number">300</span>), scheduler: <span class="type">RunLoop</span>.main)
            .<span class="function">sink</span> { [weak self] _ <span class="keyword">in</span>
                self?.<span class="function">performCalculations</span>()
            }
            .<span class="function">store</span>(in: &cancellables)
    }
}
    </div>

    <h2>Testing Architecture</h2>

    <h3>Unit Test Structure</h3>

    <div class="swift-code">
<span class="keyword">class</span> <span class="type">BillCalculationTests</span>: <span class="type">XCTestCase</span> {
    
    <span class="keyword">var</span> calculationService: <span class="type">BillCalculationService</span>!
    <span class="keyword">var</span> testContainer: <span class="type">ModelContainer</span>!
    
    <span class="keyword">override func</span> <span class="function">setUp</span>() {
        <span class="keyword">super</span>.<span class="function">setUp</span>()
        testContainer = <span class="type">ModelContainer</span>(for: <span class="type">Bill</span>.<span class="keyword">self</span>, <span class="type">Account</span>.<span class="keyword">self</span>)
        calculationService = <span class="type">BillCalculationService</span>()
    }
    
    <span class="keyword">func</span> <span class="function">testCoverageCalculation</span>() <span class="keyword">throws</span> {
        <span class="keyword">let</span> bills = <span class="function">createTestBills</span>()
        <span class="keyword">let</span> result = calculationService.<span class="function">calculateCoverage</span>(
            bills: bills,
            balance: <span class="number">2000.0</span>,
            endDate: <span class="type">Date</span>().<span class="function">addingTimeInterval</span>(<span class="number">86400</span> * <span class="number">7</span>)
        )
        
        <span class="type">XCTAssertEqual</span>(result.totalDue, <span class="number">1500.0</span>)
        <span class="type">XCTAssertEqual</span>(result.availableBalance, <span class="number">500.0</span>)
        <span class="type">XCTAssertEqual</span>(result.coverageStatus, .healthy)
    }
}
    </div>

    <h3>Performance Testing</h3>

    <div class="swift-code">
<span class="keyword">func</span> <span class="function">testCalculationPerformance</span>() <span class="keyword">throws</span> {
    <span class="keyword">let</span> bills = <span class="function">createLargeBillSet</span>(count: <span class="number">1000</span>)
    
    <span class="function">measure</span> {
        <span class="keyword">_</span> = calculationService.<span class="function">calculateCoverage</span>(
            bills: bills,
            balance: <span class="number">10000.0</span>,
            endDate: <span class="type">Date</span>().<span class="function">addingTimeInterval</span>(<span class="number">86400</span> * <span class="number">30</span>)
        )
    }
    
    <span class="comment">// Should complete in under 100ms</span>
}
    </div>

    <h2>Localization & Internationalization</h2>

    <h3>String Keys Structure</h3>

    <div class="swift-code">
<span class="comment">// Localizable.strings structure</span>
<span class="string">"bill_title" = "Bill"</span>;
<span class="string">"bill_amount" = "Amount"</span>;
<span class="string">"bill_due_date" = "Due Date"</span>;
<span class="string">"coverage_check_title" = "Coverage Check"</span>;
<span class="string">"planning_period_title" = "Planning Period"</span>;

<span class="comment">// Usage in SwiftUI</span>
<span class="type">Text</span>(<span class="type">NSLocalizedString</span>(<span class="string">"bill_title"</span>, comment: <span class="string">"Bill title"</span>))
    </div>

    <h3>Currency & Number Formatting</h3>

    <div class="swift-code">
<span class="keyword">struct</span> <span class="type">CurrencyFormatter</span> {
    <span class="keyword">static let</span> shared = <span class="type">CurrencyFormatter</span>()
    
    <span class="keyword">private let</span> formatter: <span class="type">NumberFormatter</span>
    
    <span class="keyword">init</span>() {
        formatter = <span class="type">NumberFormatter</span>()
        formatter.numberStyle = .currency
        formatter.locale = <span class="type">Locale</span>.current
    }
    
    <span class="keyword">func</span> <span class="function">format</span>(_ amount: <span class="type">Double</span>) -> <span class="type">String</span> {
        <span class="keyword">return</span> formatter.<span class="function">string</span>(from: NSNumber(value: amount)) ?? <span class="string">"$0.00"</span>
    }
}
    </div>

    <h2>Security & Privacy</h2>

    <h3>Data Protection</h3>

    <div class="warning">
        <strong>Privacy-First Design:</strong>
    </div>

    <div class="swift-code">
<span class="keyword">// No network access - fully offline</span>
<span class="keyword">@Model</span>
<span class="keyword">final class</span> <span class="type">SecureBill</span> {
    <span class="comment">// All data stored locally</span>
    <span class="keyword">private var</span> encryptedData: <span class="type">Data</span>?
    
    <span class="comment">// No analytics or tracking</span>
    <span class="comment">// No third-party SDKs</span>
    <span class="comment">// No data collection</span>
}

<span class="comment">// iCloud sync uses user's private iCloud</span>
<span class="keyword">class</span> <span class="type">PrivateCloudSync</span> {
    <span class="keyword">private func</span> <span class="function">syncToPrivateICloud</span>() {
        <span class="comment">// Syncs only to user's iCloud account</span>
        <span class="comment">// No server-side processing</span>
    }
}
    </div>

    <h3>Backup & Export Security</h3>

    <div class="swift-code">
<span class="keyword">func</span> <span class="function">createSecureBackup</span>() <span class="keyword">throws</span> -> <span class="type">Data</span> {
    <span class="keyword">let</span> backupData = <span class="keyword">try</span> <span class="function">exportAllData</span>()
    
    <span class="comment">// Optional: Add encryption layer</span>
    <span class="keyword">let</span> encryptedData = <span class="keyword">try</span> <span class="function">encryptData</span>(backupData)
    
    <span class="keyword">return</span> encryptedData
}

<span class="keyword">private func</span> <span class="function">encryptData</span>(_ data: <span class="type">Data</span>) <span class="keyword">throws</span> -> <span class="type">Data</span> {
    <span class="comment">// Uses iOS Keychain for encryption keys</span>
    <span class="comment">// AES-256 encryption</span>
}
    </div>

    <h2>Debugging & Troubleshooting</h2>

    <h3>Common Issues</h3>

    <div class="swift-code">
<span class="comment">// Debug mode for detailed logging</span>
<span class="keyword">#if DEBUG</span>
<span class="keyword">extension</span> <span class="type">BillCalculationService</span> {
    <span class="keyword">private func</span> <span class="function">logCalculation</span>(_ result: <span class="type">CoverageResult</span>) {
        print(<span class="string">"=== Calculation Debug ==="</span>)
        print(<span class="string">"Total Due: \(result.totalDue)"</span>)
        print(<span class="string">"Available: \(result.availableBalance)"</span>)
        print(<span class="string">"Status: \(result.coverageStatus)"</span>)
        print(<span class="string">"Conflicts: \(result.conflictingBills.count)"</span>)
    }
}
<span class="keyword">#endif</span>
    </div>

    <h3>Performance Monitoring</h3>

    <div class="swift-code">
<span class="keyword">class</span> <span class="type">PerformanceMonitor</span> {
    
    <span class="keyword">static func</span> <span class="function">measureCalculationTime</span>&lt;<span class="type">T</span>&gt;(
        operation: () <span class="keyword">throws</span> -> <span class="type">T</span>
    ) <span class="keyword">rethrows</span> -> <span class="type">T</span> {
        
        <span class="keyword">let</span> startTime = <span class="type">CFAbsoluteTimeGetCurrent</span>()
        <span class="keyword">let</span> result = <span class="keyword">try</span> operation()
        <span class="keyword">let</span> timeElapsed = <span class="type">CFAbsoluteTimeGetCurrent</span>() - startTime
        
        <span class="keyword">if</span> timeElapsed > <span class="number">0.1</span> {
            print(<span class="string">"⚠️ Slow calculation: \(timeElapsed)s"</span>)
        }
        
        <span class="keyword">return</span> result
    }
}
    </div>

    <h2>Future Enhancements</h2>

    <h3>Planned Features</h3>

    <div class="tip">
        <strong>Roadmap Items:</strong>
    </div>

    <ul>
        <li><strong>Advanced Analytics:</strong> Spending patterns and trends</li>
        <li><strong>Predictive Calculations:</strong> ML-based bill amount predictions</li>
        <li><strong>Enhanced Sync:</strong> Cross-device synchronization</li>
        <li><strong>Export Formats:</strong> CSV, PDF, Excel support</li>
        <li><strong>Widget Support:</strong> Home Screen and Lock Screen widgets</li>
    </ul>

    <h3>Technical Debt</h3>

    <div class="code-block">
        <strong>Areas for Improvement:</strong><br>
        • Migrate remaining legacy Core Data code<br>
        • Implement comprehensive error handling<br>
        • Add more unit tests (target: 90% coverage)<br>
        • Optimize large dataset performance<br>
        • Implement proper dependency injection
    </div>

    <h2>Conclusion</h2>
    
    <div class="api-section">
        <strong>DueDock's technical architecture prioritizes privacy, performance, and maintainability.</strong> The SwiftUI + SwiftData combination provides a modern, efficient foundation for financial management while keeping user data secure and offline.
    </div>
    
    <p>For questions or contributions, refer to the GitHub repository or contact the development team.</p>
</body>
</html>
