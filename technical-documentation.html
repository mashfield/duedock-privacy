<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculations Documentation</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 { color: #1a73e8; border-bottom: 2px solid #1a73e8; padding-bottom: 10px; }
        h2 { color: #5f6368; margin-top: 30px; }
        h3 { color: #80868b; margin-top: 25px; }
        h4 { color: #9aa0a6; margin-top: 20px; }
        code { background-color: #f1f3f4; padding: 2px 6px; border-radius: 4px; font-family: 'SF Mono', Monaco, monospace; }
        pre { 
            background-color: #f8f9fa; 
            padding: 15px; 
            border-radius: 8px; 
            overflow-x: auto;
            font-family: 'SF Mono', Monaco, monospace;
        }
        blockquote { 
            border-left: 4px solid #1a73e8; 
            padding-left: 15px; 
            margin: 20px 0; 
            color: #5f6368; 
        }
        ul { margin: 15px 0; }
        li { margin: 5px 0; }
        strong { color: #1a73e8; }
    </style>
</head>
<body>
<h1>DueDock Calculations Documentation</h1><p>This document provides a comprehensive overview of all calculations, variables, and financial logic used throughout the DueDock application.</p><h2>Table of Contents</h2><br>1. <a href="#core-data-models--their-calculations">Core Data Models & Their Calculations</a><br>2. <a href="#dashboard-calculations">Dashboard Calculations</a><br>3. <a href="#coverage-check-calculations">Coverage Check Calculations</a><br>4. <a href="#bill-payment-calculations">Bill Payment Calculations</a><br>5. <a href="#installment-payment-calculations">Installment Payment Calculations</a><br>6. <a href="#income--period-calculations">Income & Period Calculations</a><br>7. <a href="#savings-goal-calculations">Savings Goal Calculations</a><br>8. <a href="#filter--display-calculations">Filter & Display Calculations</a><br>9. <a href="#test-coverage--expected-behaviors">Test Coverage & Expected Behaviors</a></p><p>---</p><h2>Core Data Models & Their Calculations</h2><h3>Bill Model (<code>Bill.swift</code>)</h3><h4>Core Properties</h4><br>- <code>amount: Double</code> - Base bill amount<br>- <code>paidAmount: Double</code> - Amount already paid<br>- <code>actualAmount: Double?</code> - Variable bill actual amount (if applicable)<br>- <code>partialPaymentAmount: Double</code> - Installment payment amount<br>- <code>paidTowardsInstallment: Double</code> - Amount paid toward installment</p><h4>Computed Properties</h4><br><pre><code>// Current amount (variable or fixed)<br>var currentAmount: Double { <br>    isVariable ? (actualAmount ?? amount) : amount <br>}</p><p>// Remaining amount to be paid<br>var remainingAmount: Double { <br>    currentAmount - paidAmount <br>}</p><p>// Payment progress (0.0 to 1.0)<br>var progress: Double {<br>    guard currentAmount > 0 else { return 0 }<br>    return paidAmount / currentAmount<br>}</p><p>// Whether bill is partially paid<br>var isPartiallyPaid: Bool { <br>    paidAmount > 0 && paidAmount < currentAmount <br>}</p><p>// Whether bill should stay visible (has installments)<br>var shouldStayVisible: Bool {<br>    return isPartialPaymentScheduled<br>}</code></pre><h3>Account Model (<code>Account.swift</code>)</h3><br><pre><code>var actualBalance: Double = 0.0  // Current account balance</code></pre><h3>Income Model (<code>Income.swift</code>)</h3><br><pre><code>var amount: Double        // Income amount<br>var receivedDate: Date    // When income is received</code></pre><h3>SavingsGoal Model (<code>SavingsGoal.swift</code>)</h3><br><pre><code>var targetAmount: Double           // Goal target amount<br>var amountContributed: Double      // Amount already contributed</p><p>// Remaining amount needed<br>var remainingAmount: Double { <br>    targetAmount - amountContributed <br>}</p><p>// Progress percentage (0.0 to 1.0)<br>var progress: Double {<br>    guard targetAmount > 0 else { return 0 }<br>    return amountContributed / targetAmount<br>}</p><p>// Whether goal is partially funded<br>var isPartiallyFunded: Bool { <br>    amountContributed > 0 && amountContributed < targetAmount <br>}</code></pre><p>---</p><h2>Dashboard Calculations</h2><h3>Period Boundary Calculations</h3><br><pre><code>// Start of current period (usually today)<br>let startOfPeriodBoundary = Calendar.current.startOfDay(for: .now)</p><p>// End of period based on coverage period multiplier<br>let endOfPeriodBoundary = Calendar.current.startOfDay(for: <br>    Calendar.current.date(byAdding: .day, value: coveragePeriodDays, to: startOfPeriodBoundary) ?? startOfPeriodBoundary<br>)</code></pre><h3>Income Calculations</h3><br><pre><code>// Filter incomes within current period<br>private var incomesInPeriod: [Income] { <br>    incomes.filter { $0.receivedDate >= startOfPeriodBoundary && $0.receivedDate < endOfPeriodBoundary } <br>}</p><p>// Total income in current period<br>private var totalIncomeInPeriod: Double { <br>    incomesInPeriod.reduce(0) { $0 + $1.amount } <br>}</code></pre><h3>Bill Totals</h3><br><pre><code>// Grand total of all bills in pay period<br>private var grandTotalBills: Double {<br>    billItemsInPayPeriod.reduce(0) { $0 + $1.amount }<br>}</code></pre><h3>Section Totals (Performance Optimization)</h3><br><pre><code>// Cached section totals to prevent excessive recalculation<br>@State private var sectionTotals: [String: Double] = [:]</p><p>private func updateSectionTotals() {<br>    var newTotals: [String: Double] = [:]<br>    let boundaryDate = endOfPeriodBoundary<br>    let startDate = startOfPeriodBoundary<br>    <br>    // Calculate totals for each account section<br>    for bill in filteredBills {<br>        let amount = calculateBillAmountForSection(bill: bill, now: Date(), endOfPeriodBoundary: boundaryDate)<br>        if let accountName = bill.account?.name {<br>            newTotals[accountName, default: 0] += amount<br>        }<br>    }<br>    <br>    sectionTotals = newTotals<br>}</code></pre><p>---</p><h2>Coverage Check Calculations</h2><h3>Coverage Items Update Logic</h3><br><pre><code>private func updateCoverageItems(source: String = "unknown") {<br>    let now = Date()<br>    <br>    // Find next income date for boundary calculation<br>    let nextIncomeDate = getNextIncomeDate() ?? Calendar.current.date(byAdding: .day, value: 30, to: now)!<br>    let boundaryDate = Calendar.current.startOfDay(for: nextIncomeDate)<br>    let startDate = Calendar.current.startOfDay(for: now)<br>    <br>    var items: [CoverageItem] = []<br>    <br>    for bill in filteredBills {<br>        let billDate = Calendar.current.startOfDay(for: bill.nextDueDate)<br>        let isSameDayConflict = billDate == boundaryDate<br>        <br>        // Check for partial payment conflicts<br>        var partialPaymentConflict = false<br>        if installmentsEnabled, bill.isPartialPaymentScheduled, let partialDate = bill.nextPartialPaymentDate {<br>            partialPaymentConflict = Calendar.current.startOfDay(for: partialDate) == boundaryDate<br>        }<br>        <br>        // Include same-day bills with override<br>        if (isSameDayConflict || partialPaymentConflict) && bill.includeInCoverageOverride {<br>            // Handle installment bills for same-day conflicts<br>            if installmentsEnabled && bill.isPartialPaymentScheduled && <br>               let nextPaymentDate = bill.nextPartialPaymentDate,<br>               nextPaymentDate >= startDate && nextPaymentDate <= boundaryDate {<br>                <br>                let remainingInstallment = bill.partialPaymentAmount - bill.paidTowardsInstallment<br>                if remainingInstallment > 0 {<br>                    items.append(CoverageItem(<br>                        name: "\(bill.name) (Partial)", <br>                        dueDate: nextPaymentDate, <br>                        amount: remainingInstallment, <br>                        isPartialPayment: true<br>                    ))<br>                }<br>            } else if !isSameDayConflict && bill.nextDueDate >= startDate && bill.nextDueDate <= boundaryDate {<br>                let amount = bill.shouldStayVisible ? bill.remainingAmount : bill.currentAmount<br>                items.append(CoverageItem(<br>                    name: bill.name, <br>                    dueDate: bill.nextDueDate, <br>                    amount: amount, <br>                    isPartialPayment: false<br>                ))<br>            }<br>        }<br>        // Regular bills (non-same-day conflicts)<br>        else if !isSameDayConflict && !partialPaymentConflict {<br>            // Use partial payment date for installment bills, due date for regular bills<br>            let billDate = installmentsEnabled && bill.isPartialPaymentScheduled ? <br>                bill.nextPartialPaymentDate ?? bill.nextDueDate : bill.nextDueDate<br>            <br>            if billDate >= startDate && billDate <= boundaryDate {<br>                if installmentsEnabled && bill.isPartialPaymentScheduled && <br>                   let nextPaymentDate = bill.nextPartialPaymentDate,<br>                   nextPaymentDate >= startDate && nextPaymentDate <= boundaryDate {<br>                    <br>                    let remainingInstallment = bill.partialPaymentAmount - bill.paidTowardsInstallment<br>                    if remainingInstallment > 0 {<br>                        items.append(CoverageItem(<br>                            name: "\(bill.name) (Partial)", <br>                            dueDate: nextPaymentDate, <br>                            amount: remainingInstallment, <br>                            isPartialPayment: true<br>                        ))<br>                    }<br>                } else {<br>                    let amount = bill.shouldStayVisible ? bill.remainingAmount : bill.currentAmount<br>                    items.append(CoverageItem(<br>                        name: bill.name, <br>                        dueDate: bill.nextDueDate, <br>                        amount: amount, <br>                        isPartialPayment: false<br>                    ))<br>                }<br>            }<br>        }<br>    }<br>    <br>    coverageItems = items.sorted { $0.dueDate < $1.dueDate }<br>}</code></pre><h3>Coverage Total Calculation</h3><br><pre><code>private var totalForCoverageItems: Double {<br>    let regularBillsTotal = coverageItemsBeforeNextIncome.reduce(0) { $0 + $1.amount }<br>    let sameDayBillsTotal = billsWithSameDayConflict.reduce(0) { total, bill in<br>        // Only include same-day bills with override flag<br>        bill.includeInCoverageOverride ? total + bill.currentAmount : total<br>    }<br>    return regularBillsTotal + sameDayBillsTotal<br>}</code></pre><h3>Coverage Percentage</h3><br><pre><code>// Coverage percentage calculation (handles division by zero)<br>let coveragePercentage = totalIncome > 0 ? totalBills / totalIncome : 0.0</code></pre><p>---</p><h2>Bill Payment Calculations</h2><h3>Bill Period Items Update</h3><br><pre><code>private func updateBillPaymentsInPeriod() {<br>    var items: [BillPeriodItem] = []<br>    let now = Calendar.current.startOfDay(for: .now)<br>    let endOfPeriodBoundary = Calendar.current.startOfDay(for: <br>        Calendar.current.date(byAdding: .day, value: coveragePeriodDays, to: now) ?? now<br>    )<br>    <br>    for bill in filteredBills {<br>        // Handle installment bills<br>        if installmentsEnabled && bill.isPartialPaymentScheduled {<br>            if let partialDate = bill.nextPartialPaymentDate, <br>               partialDate >= now && partialDate < endOfPeriodBoundary {<br>                <br>                let remainingInstallment = bill.partialPaymentAmount - bill.paidTowardsInstallment<br>                if remainingInstallment > 0 {<br>                    items.append(BillPeriodItem(<br>                        name: "\(bill.name) (Partial)", <br>                        amount: remainingInstallment<br>                    ))<br>                }<br>            }<br>        } <br>        // Handle regular bills<br>        else if bill.nextDueDate >= now && bill.nextDueDate < endOfPeriodBoundary {<br>            items.append(BillPeriodItem(<br>                name: bill.name, <br>                amount: bill.currentAmount<br>            ))<br>        }<br>    }<br>    <br>    billItemsInPayPeriod = items.sorted { $0.name < $1.name }<br>}</code></pre><h3>Bill Amount Calculation for Sections</h3><br><pre><code>private func calculateBillAmountForSection(bill: Bill, now: Date, endOfPeriodBoundary: Date) -> Double {<br>    let incomeDate = lastCoverageIncome?.receivedDate ?? Date()<br>    let incomeBoundary = Calendar.current.startOfDay(for: incomeDate)<br>    let billDate = Calendar.current.startOfDay(for: bill.nextDueDate)<br>    let isSameDayConflict = billDate == incomeBoundary<br>    <br>    var partialPaymentConflict = false<br>    if installmentsEnabled, bill.isPartialPaymentScheduled, let partialDate = bill.nextPartialPaymentDate {<br>        partialPaymentConflict = Calendar.current.startOfDay(for: partialDate) == incomeBoundary<br>    }<br>    <br>    var amountToAdd = 0.0<br>    <br>    // Same-day conflict logic<br>    if (isSameDayConflict || partialPaymentConflict) && bill.includeInCoverageOverride {<br>        if installmentsEnabled && bill.isPartialPaymentScheduled && <br>           let nextPaymentDate = bill.nextPartialPaymentDate,<br>           nextPaymentDate >= now && nextPaymentDate <= endOfPeriodBoundary {<br>            <br>            let remainingInstallment = bill.partialPaymentAmount - bill.paidTowardsInstallment<br>            amountToAdd = remainingInstallment<br>        } else if !isSameDayConflict && bill.nextDueDate >= now && bill.nextDueDate <= endOfPeriodBoundary {<br>            // CRITICAL: Use remainingAmount for regular bills with partial payments<br>            amountToAdd = bill.remainingAmount<br>        }<br>    }<br>    // Regular logic for non-same-day bills<br>    else if installmentsEnabled && bill.isPartialPaymentScheduled,<br>            let partialDate = bill.nextPartialPaymentDate,<br>            partialDate >= now && partialDate <= endOfPeriodBoundary {<br>        <br>        amountToAdd = bill.partialPaymentAmount - bill.paidTowardsInstallment<br>    } else if bill.nextDueDate >= now && bill.nextDueDate <= endOfPeriodBoundary {<br>        // CRITICAL: Use remainingAmount for regular bills with partial payments<br>        amountToAdd = bill.remainingAmount<br>    }<br>    <br>    return amountToAdd<br>}</code></pre><p><strong>ðŸš¨ CRITICAL IMPLEMENTATION NOTE:</strong><br>- For <strong>regular bills</strong> (not installment) with partial payments: <strong>ALWAYS</strong> use <code>bill.remainingAmount</code><br>- For <strong>installment bills</strong>: Use <code>bill.partialPaymentAmount - bill.paidTowardsInstallment</code><br>- <strong>NEVER</strong> use <code>bill.currentAmount</code> for bills that may have partial payments<br>- This prevents calculation errors like the "Christmas Gifts" bill bug</p><h3>Coverage Items Update Logic</h3><br><pre><code>private func updateCoverageItems(source: String = "unknown") {<br>    let now = Date()<br>    <br>    // Find next income date for boundary calculation<br>    let nextIncomeDate = getNextIncomeDate() ?? Calendar.current.date(byAdding: .day, value: 30, to: now)!<br>    let boundaryDate = Calendar.current.startOfDay(for: nextIncomeDate)<br>    let startDate = Calendar.current.startOfDay(for: now)<br>    <br>    var items: [CoverageItem] = []<br>    <br>    for bill in filteredBills {<br>        let billDate = Calendar.current.startOfDay(for: bill.nextDueDate)<br>        let isSameDayConflict = billDate == boundaryDate<br>        <br>        // Check for partial payment conflicts<br>        var partialPaymentConflict = false<br>        if installmentsEnabled, bill.isPartialPaymentScheduled, let partialDate = bill.nextPartialPaymentDate {<br>            partialPaymentConflict = Calendar.current.startOfDay(for: partialDate) == boundaryDate<br>        }<br>        <br>        // Include same-day bills if they have the override flag<br>        if (isSameDayConflict || partialPaymentConflict) && bill.includeInCoverageOverride {<br>            if installmentsEnabled,<br>               bill.isPartialPaymentScheduled,<br>               let nextPaymentDate = bill.nextPartialPaymentDate,<br>               nextPaymentDate >= startDate && nextPaymentDate <= boundaryDate {</p><p>                let remainingInstallment = bill.partialPaymentAmount - bill.paidTowardsInstallment<br>                if remainingInstallment > 0 {<br>                    items.append(CoverageItem(name: "\(bill.name) (Partial)", dueDate: nextPaymentDate, amount: remainingInstallment, isPartialPayment: true))<br>                }<br>            } else if !isSameDayConflict && bill.nextDueDate >= startDate && bill.nextDueDate <= boundaryDate {<br>                // CRITICAL: Use remainingAmount for regular bills with partial payments<br>                let amount = bill.remainingAmount<br>                items.append(CoverageItem(name: bill.name, dueDate: bill.nextDueDate, amount: amount, isPartialPayment: false))<br>            }<br>        }<br>        // CRITICAL: Add regular bills (non-same-day conflicts)<br>        else if !isSameDayConflict && !partialPaymentConflict {<br>            // Check if bill is in range (use partial payment date for installments)<br>            let billDate = installmentsEnabled && bill.isPartialPaymentScheduled ? <br>                bill.nextPartialPaymentDate ?? bill.nextDueDate : bill.nextDueDate<br>            <br>            if billDate >= startDate && billDate <= boundaryDate {<br>                if installmentsEnabled,<br>                   bill.isPartialPaymentScheduled,<br>                   let nextPaymentDate = bill.nextPartialPaymentDate,<br>                   nextPaymentDate >= startDate && nextPaymentDate <= boundaryDate {<br>                    <br>                    let remainingInstallment = bill.partialPaymentAmount - bill.paidTowardsInstallment<br>                    if remainingInstallment > 0 {<br>                        items.append(CoverageItem(name: "\(bill.name) (Partial)", dueDate: nextPaymentDate, amount: remainingInstallment, isPartialPayment: true))<br>                    }<br>                } else {<br>                    // CRITICAL: Use remainingAmount for regular bills with partial payments<br>                    let amount = bill.remainingAmount<br>                    items.append(CoverageItem(name: bill.name, dueDate: bill.nextDueDate, amount: amount, isPartialPayment: false))<br>                }<br>            }<br>        }<br>    }<br>    <br>    // Update state<br>    coverageItems = items.sorted { $0.dueDate < $1.dueDate }<br>    lastCoverageUpdate = Date()<br>}</code></pre><p>---</p><h2>Installment Payment Calculations</h2><h3>Installment Display Amount</h3><br><pre><code>// For UI display - shows remaining installment amount or remaining bill amount<br>private var displayAmount: Double {<br>    isPartialPaymentDue ? max(0, bill.partialPaymentAmount - bill.paidTowardsInstallment) : bill.remainingAmount<br>}</p><p>// Check if partial payment is due<br>private var isPartialPaymentDue: Bool {<br>    bill.isPartialPaymentScheduled && (bill.partialPaymentAmount - bill.paidTowardsInstallment) > 0<br>}</code></pre><h3>Installment Remaining Calculation</h3><br><pre><code>// Standard calculation used throughout the app<br>let remainingInstallment = bill.partialPaymentAmount - bill.paidTowardsInstallment</code></pre><p>---</p><h2>Income & Period Calculations</h2><h3>Period Days Calculation</h3><br><pre><code>// Total days in current period<br>private var totalDaysInPeriod: Int {<br>    Calendar.current.dateComponents([.day], from: periodStartDate, to: periodEndDate).day ?? 1<br>}</code></pre><h3>Coverage Period Multiplier</h3><br><pre><code>// Days to look ahead based on multiplier (1x = next income, 2x = income after next, etc.)<br>let coveragePeriodDays = coveragePeriodMultiplier * averageDaysBetweenIncomes</code></pre><h3>Income in Period Calculation</h3><br><pre><code>// Filter and sum incomes within a specific period<br>let incomesInPeriod = incomes.filter { income in<br>    income.receivedDate >= periodStart && income.receivedDate < periodEnd<br>}<br>let totalIncomeInPeriod = incomesInPeriod.reduce(0) { $0 + $1.amount }</code></pre><p>---</p><h2>Savings Goal Calculations</h2><h3>Progress Calculation</h3><br><pre><code>// Percentage progress toward savings goal<br>var progress: Double {<br>    guard targetAmount > 0 else { return 0 }<br>    return amountContributed / targetAmount<br>}</p><p>// Remaining amount needed<br>var remainingAmount: Double { <br>    targetAmount - amountContributed <br>}</code></pre><p>---</p><h2>Filter & Display Calculations</h2><h3>Amount Filtering</h3><br><pre><code>// Filter bills by amount range<br>let filteredByAmount = bills.filter { bill in<br>    let amount = bill.currentAmount<br>    let minFilter = filterMinAmount ?? 0<br>    let maxFilter = filterMaxAmount ?? Double.greatestFiniteMagnitude<br>    return amount >= minFilter && amount <= maxFilter<br>}</code></pre><h3>Payment Status Filtering</h3><br><pre><code>enum PaymentStatusFilter {<br>    case all, unpaid, partiallyPaid, fullyPaid<br>}</p><p>// Filter bills by payment status<br>let filteredByStatus = bills.filter { bill in<br>    switch filterByPaymentStatus {<br>    case .all: return true<br>    case .unpaid: return bill.paidAmount == 0<br>    case .partiallyPaid: return bill.isPartiallyPaid<br>    case .fullyPaid: return bill.paidAmount >= bill.currentAmount<br>    }<br>}</code></pre><p>---</p><h2>Test Coverage & Expected Behaviors</h2><h3>Coverage Calculation Tests</h3><br><pre><code>// Full coverage: $1000 income, $800 bills = 80% coverage<br>let coverage = 800.0 / 1000.0  // Expected: 0.80</p><p>// Over coverage: $1000 income, $1200 bills = 120% coverage  <br>let coverage = 1200.0 / 1000.0  // Expected: 1.20</p><p>// Partial coverage: $1000 income, $500 bills = 50% coverage<br>let coverage = 500.0 / 1000.0   // Expected: 0.50</p><p>// Zero income edge case: $0 income, $500 bills = 0% coverage<br>let coverage = income > 0 ? bills / income : 0.0  // Expected: 0.0</code></pre><h3>Edge Cases Handled</h3><br>1. <strong>Division by zero</strong>: All percentage calculations check for zero income<br>2. <strong>Negative amounts</strong>: <code>max(0, amount)</code> used to prevent negative display values<br>3. <strong>Date boundaries</strong>: Uses <code>startOfDay</code> for consistent date comparisons<br>4. <strong>Installment completion</strong>: Checks <code>remainingInstallment > 0</code> before adding to calculations<br>5. <strong>Same-day conflicts</strong>: Special logic for bills due on same day as income</p><h3>Performance Optimizations</h3><br>1. <strong>Section totals caching</strong>: Prevents excessive recalculation of account section totals<br>2. <strong>Debounced updates</strong>: Coverage items update only after minimum time interval<br>3. <strong>Conditional calculations</strong>: Skip expensive calculations when data hasn't changed</p><p>---</p><h2>Important Notes</h2><p>1. <strong>Currency Handling</strong>: All calculations use <code>Double</code> for precision, formatted for display using <code>FloatingPointFormatStyle<Double>.Currency</code><br>2. <strong>Date Consistency</strong>: All date comparisons use <code>startOfDay</code> to avoid time-of-day issues<br>3. <strong>Installment Logic</strong>: Installment bills use <code>nextPartialPaymentDate</code> for period calculations, not <code>nextDueDate</code><br>4. <strong>Override Flags</strong>: <code>includeInCoverageOverride</code> allows same-day bills to be included in coverage calculations<br>5. <strong>Variable Bills</strong>: <code>actualAmount</code> takes precedence over <code>amount</code> when <code>isVariable</code> is true</p><p>---</p><p><em>Last Updated: December 17, 2025</em><br><em>Version: 2.6.2</em><br></p>
</body>
</html>